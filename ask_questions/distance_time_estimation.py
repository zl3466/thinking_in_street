from utils import *


def main():
    data_dir = "../data/long_route_random_single"
    question_dir = f"../ask_questions/distance_estimation"
    map_list = os.listdir(data_dir)

    # map_name = "map1_downtown_bk"
    for map_name in map_list:
        print("====================================")
        print(f"Processing Map {map_name}")
        map_root_dir = f"{data_dir}/{map_name}"
        out_dir = f"{data_dir}/{map_name}/distance_time_estimate"
        if not os.path.exists(map_root_dir):
            print(f"Directory not found: {map_root_dir}")
            return
        if not os.path.exists(out_dir):
            os.makedirs(out_dir, exist_ok=True)

        location_dict = json.load(open(f"{question_dir}/{map_name}.json"))
        start = location_dict["Q"]["start"]
        end = location_dict["Q"]["end"]
        GT_start = location_dict["GT"]["start"]
        GT_end = location_dict["GT"]["end"]

        question_list = [
            "Give me five landmarks you saw in this footage.",

            f"Do you see the following locations in this footage? {start}, {end}",

            f"The images I uploaded covers most of the streets within an area. I want to go from {start} to {end}. Using "
            f"the spatial information you collect from the images I uploaded, what is the estimated distance to travel by "
            f"driving from {start} to {end}? Give me one single numerical value (not a range) as exact as possible.",

            f"The images I uploaded covers most of the streets within an area. I want to go from {start} to {end}. Using "
            f"the spatial information you collect from the images I uploaded, what is the estimated duration to travel by "
            f"driving from {start} to {end}? What about by walk? Give me one single numerical value (not a range) as "
            f"exact as possible."
        ]

        ''' ================== Inference ================== '''
        ''' upload images to model and ask questions '''
        results = analyze_street_view(map_root_dir, question_list, out_dir=map_root_dir)

        ''' ================== save questions and answers in md and json ================== '''
        ''' the json could be used later for auto eval? '''
        if os.path.exists(f"{out_dir}/Q&A.md"):
            os.remove(f"{out_dir}/Q&A.md")
        if results:
            print("\nAnalysis Summary:")
            for question, answer in results.items():
                print(f"\n{question}")
                print(f"{answer}")
                with open(f"{out_dir}/Q&A.md", "a", encoding="utf-8") as file:
                    file.write(f"{question}")
                    file.write(f"{answer}")
        with open(f"{out_dir}/Q&A.json", 'w') as f:
            json.dump(results, f, indent=4)

        ''' ================== Save Ground Truth Route Data ================== '''
        ''' the optimal order is manually regulated, and the route is generated by Google Maps '''

        route_data = {
            "map": map_name,
            "distance_gt": "",
            "duration_gt": "",
            "frames": [],
        }
        all_positions_and_headings, distance_gt, duration_gt = get_routes_from_locations([GT_start, GT_end], f"{out_dir}/route_map_distance_time_estimate.html")
        route_data["distance_gt"] = distance_gt
        route_data["duration_gt"] = duration_gt
        for idx, (lat, lng, heading, movement) in tqdm(enumerate(all_positions_and_headings),
                                                       total=len(all_positions_and_headings)):
            # Store frame data with the movement from all_positions_and_headings
            route_data["frames"].append({
                "coordinates": {"lat": lat, "lng": lng},
                "heading": heading,
                "movement": movement  # This now correctly uses the movement we determined earlier
            })

        # Save route data to JSON
        route_data_file = f"{out_dir}/route_data_distance_time_estimate.json"
        with open(route_data_file, 'w') as f:
            json.dump(route_data, f, indent=2)



if __name__ == "__main__":
    main()
